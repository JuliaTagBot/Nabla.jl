<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Custom Sensitivities · Nabla.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/invenia.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Nabla.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="api.html">API</a></li><li class="current"><a class="toctext" href="custom.html">Custom Sensitivities</a><ul class="internal"><li><a class="toctext" href="#Intercepting-calls-1">Intercepting calls</a></li><li><a class="toctext" href="#Defining-sensitivities-1">Defining sensitivities</a></li><li><a class="toctext" href="#Testing-sensitivities-1">Testing sensitivities</a></li></ul></li><li><a class="toctext" href="autodiff.html">Details</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="custom.html">Custom Sensitivities</a></li></ul><a class="edit-page" href="https://github.com/invenia/Nabla.jl/blob/master/docs/src/pages/custom.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Custom Sensitivities</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Custom-Sensitivities-1" href="#Custom-Sensitivities-1">Custom Sensitivities</a></h1><p>Part of the power of Nabla is its extensibility, specifically in the form of defining custom sensitivities for functions. This is accomplished by defining methods for <code>∇</code> that specialize on the function for which you&#39;d like to define sensitivities.</p><p>Given a function of the form <span>$f(x_1, \ldots, x_n)$</span>, we want to be able to compute <span>$\frac{\partial f}{\partial x_i}$</span> for all <span>$i$</span> of interest as efficiently as possible. Defining our own sensitivities <span>$\bar{x}_i$</span> means that <span>$f$</span> will be taken as a &quot;unit,&quot; and its intermediate operations are not written separately to the tape. For more details on that, refer to the <a href="autodiff.html#Automatic-Differentiation-1">Details</a> section of the documentation.</p><h2><a class="nav-anchor" id="Intercepting-calls-1" href="#Intercepting-calls-1">Intercepting calls</a></h2><p>Nabla&#39;s approach to RMAD is based on operator overloading. Specifically, for each <span>$x_i$</span> we wish to differentiate, we need a method for <code>f</code> that accepts a <code>Node</code> in position <span>$i$</span>. There are two primary ways to go about this: <code>@explicit_intercepts</code> and <code>@unionise</code>.</p><h3><a class="nav-anchor" id="@explicit_intercepts-1" href="#@explicit_intercepts-1"><code>@explicit_intercepts</code></a></h3><p>When <code>f</code> has already been defined, we can extend it to accept <code>Node</code>s using this macro.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.@explicit_intercepts" href="#Nabla.@explicit_intercepts"><code>Nabla.@explicit_intercepts</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@explicit_intercepts(f::Symbol, type_tuple::Expr, is_node::Expr[, kwargs::Expr])
@explicit_intercepts(f::Symbol, type_tuple::Expr)</code></pre><p>Create a collection of methods which intecept the function calls to <code>f</code> in which at least one argument is a <code>Node</code>. Types of arguments are specified by the type tuple expression in <code>type_tuple</code>. If there are arguments which are not differentiable, they can be specified by providing a boolean vector <code>is_node</code> which indicates those arguments that are differentiable with <code>true</code> values and those which are not as <code>false</code>. Keyword arguments to add to the function signature can be specified in <code>kwargs</code>, which must be a <code>NamedTuple</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Nabla.jl/blob/0aa0c20340faead803694d6f33880cce0ad39a95/src/sensitivity.jl#L39-L49">source</a></section><p>As a trivial example, take <code>sin</code> for scalar values (not matrix sine). We extend it for <code>Node</code>s as</p><pre><code class="language-julia">import Base: sin  # ensure sin can be extended without qualification

@explicit_intercepts sin Tuple{Real}</code></pre><p>This generates the following code:</p><pre><code class="language-julia">begin
    function sin(##367::Node{&lt;:Real})
        #= REPL[7]:1 =#
        Branch(sin, (##367,), getfield(##367, :tape))
    end
end</code></pre><p>And so calling <code>sin</code> with a <code>Node</code> argument will produce a <code>Branch</code> that holds information about the call.</p><p>For a nontrivial example, take the <code>sum</code> function, which accepts a function argument that gets mapped over the input prior to reduction by addition, as well as a <code>dims</code> keyword argument that permits summing over a subset of the dimensions of the input. We want to differentiate with respect to the input array, but not with respect to the function argument nor the dimension. (Note that Nabla cannot currently differentiate with respect to keyword arguments.) We can extend this for <code>Node</code>s as</p><pre><code class="language-julia">import Base: sum

@explicit_intercepts(
    sum,
    Tuple{Function, AbstractArray{&lt;:Real}},
    [false, true],
    (dims=:,),
)</code></pre><p>The signature of the call to <code>@explicit_intercepts</code> here may look a bit complex, so let&#39;s break it down. It&#39;s saying that we want to intercept calls to <code>sum</code> for methods which accept a <code>Function</code> and an <code>AbstractArray{&lt;:Real}</code>, and that we do not want to differentiate with respect to the function argument (<code>false</code>) but do want to differentiate with respect to the array (<code>true</code>). Furthermore, methods of this form will have the keyword argument <code>dims</code>, which defaults to <code>:</code>, and we&#39;d like to make sure we&#39;re able to capture that when we intercept.</p><p>This macro generates the following code:</p><pre><code class="language-none">function _sum(arg1::Function, arg2::AbstractArray{&lt;:Real}, dims=:)
    #= REPL[6]:1 =#
    sum(arg1, arg2; dims=dims)
end
begin
    begin
        function sum(##365::Function, ##366::Node{&lt;:AbstractArray{&lt;:Real}}; dims=:)
            #= REPL[6]:1 =#
            _sum(##365, ##366, dims)
        end
        function _sum(##365::Function, ##366::Node{&lt;:AbstractArray{&lt;:Real}}, dims::Any)
            #= REPL[6]:1 =#
            Branch(_sum, (##365, ##366, dims), getfield(##366, :tape))
        end
    end
end</code></pre><p>As you can see, it defines a new function <code>_sum</code> which has all positional arguments but is otherwise equivalent to <code>sum</code>. It then extends <code>sum</code> to call <code>_sum</code> when passed a <code>Node</code> for the input array, and <code>_sum</code> in turn creates a <code>Branch</code> when it receives a <code>Node</code>. Notice that we do not accept a <code>Node</code> for the function argument; this is by virtue of using <code>false</code> in that position in the call to <code>@explicit_intercepts</code>.</p><p>The name <code>_sum</code> is generated by an internal function <code>Nabla.kwfname</code>, which generates a name for a function that accepts positional arguments based on one with keyword arguments. Currently the naming scheme is to simply prepend an underscore.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>When dealing with functions with keyword arguments, methods for <code>∇</code> should be specialized on <code>Nabla.kwfname(f)</code>, <em>not</em> <code>f</code>!</p></div></div><h3><a class="nav-anchor" id="@unionise-1" href="#@unionise-1"><code>@unionise</code></a></h3><p>If <code>f</code> has not yet been defined and you know off the bat that you want it to be able to work with Nabla, you can annotate its definition with <code>@unionise</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.@unionise" href="#Nabla.@unionise"><code>Nabla.@unionise</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@unionise code</code></pre><p>Transform code such that each function definition accepts <code>Node</code> objects as arguments, without effecting dispatch in other ways.</p></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Nabla.jl/blob/0aa0c20340faead803694d6f33880cce0ad39a95/src/code_transformation/differentiable.jl#L149-L154">source</a></section><p>As a simple example,</p><pre><code class="language-julia">@unionise f(x::Matrix, p::Real) = norm(x, p)</code></pre><p>For each type constrained argument <code>xi</code> in the method definition&#39;s signature, <code>@unionise</code> changes the type constraint from <code>T</code> to <code>Union{T, Node{&lt;:T}}</code>, allowing <code>f</code> to work with <code>Node</code>s without needing to define separate methods. In this example, the macro expands the definition to</p><pre><code class="language-julia">f(x::Union{Matrix, Node{&lt;:Matrix}}, p::Union{Real, Node{&lt;:Real}}) = begin
        #= REPL[9]:1 =#
        norm(x, p)
    end</code></pre><h2><a class="nav-anchor" id="Defining-sensitivities-1" href="#Defining-sensitivities-1">Defining sensitivities</a></h2><p>Now that our function <code>f</code> works with <code>Node</code>s, we want to define a method for <code>∇</code> for each argument <code>xi</code> that we&#39;re interested in differentiating. Thus, for each argument position <code>i</code> we care about, we&#39;ll define a method of <code>∇</code> that looks like:</p><pre><code class="language-julia">function Nabla.∇(::typeof(f), ::Type{Arg{i}}, _, y, ȳ, x1, ..., xn)
    # Compute x̄i
end</code></pre><p>The method signature contains all of the information it needs to compute the derivative:</p><ul><li><code>f</code>, the function</li><li><code>Arg{i}</code>, which specifies which of the <code>xi</code> we&#39;re computing the sensitivity of</li><li><code>_</code> (placeholder, typically unused)</li><li><code>y</code>, the result of <code>y = f(x1, ..., xn)</code></li><li><code>ȳ</code>, the &quot;incoming&quot; sensitivity propagated to this call</li><li><code>x1, ..., xn</code>, the inputs to <code>f</code></li></ul><p>A fully worked example is provided in the <a href="autodiff.html#Automatic-Differentiation-1">Details</a> section of the documentation.</p><p>As stated earlier, if <code>f</code> accepts keyword arguments then we&#39;ll need to extend <code>∇</code> for <code>Nabla.kwfname(f)</code> rather than <code>f</code>. However, note that <code>kwfname</code> returns a <code>Symbol</code>, not a <code>Function</code>, which means a bit of trickery is involved when forming the method signature. One effective, if not entirely beautiful, way to accomplish it is to use <code>@eval</code>:</p><pre><code class="language-julia">@eval function Nabla.∇(::typeof($(Nabla.kwfname(f))), ...)
    # ...
end</code></pre><h2><a class="nav-anchor" id="Testing-sensitivities-1" href="#Testing-sensitivities-1">Testing sensitivities</a></h2><p>In order to ensure correctness for custom sensitivity definitions, we can compare the results against those computed by the method of finite differences. The finite differencing itself is implemented in the Julia package <a href="https://github.com/invenia/FDM.jl">FDM</a>, but Nabla defines and exports functionality that permits checking results against finite differencing.</p><p>The primary workhorse function for this is <code>check_errs</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nabla.check_errs" href="#Nabla.check_errs"><code>Nabla.check_errs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">check_errs(
    f,
    ȳ::∇ArrayOrScalar,
    x::T,
    v::T,
    ε_abs::∇Scalar=1e-10,
    ε_rel::∇Scalar=1e-7
)::Bool where T</code></pre><p>Check that the difference between finite differencing directional derivative estimation and RMAD directional derivative computation for function <code>f</code> at <code>x</code> in direction <code>v</code>, for both allocating and in-place modes, has absolute and relative errors of <code>ε_abs</code> and <code>ε_rel</code> respectively, when scaled by reverse-mode sensitivity <code>ȳ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/invenia/Nabla.jl/blob/0aa0c20340faead803694d6f33880cce0ad39a95/src/finite_differencing.jl#L91-L105">source</a></section><footer><hr/><a class="previous" href="api.html"><span class="direction">Previous</span><span class="title">API</span></a><a class="next" href="autodiff.html"><span class="direction">Next</span><span class="title">Details</span></a></footer></article></body></html>
